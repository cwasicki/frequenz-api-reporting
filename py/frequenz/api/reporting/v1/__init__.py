# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: frequenz/api/reporting/v1/reporting.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common.v1 import (
    metrics as __common_v1_metrics__,
    microgrid as __common_v1_microgrid__,
    pagination as __common_v1_pagination__,
)
from ...common.v1.microgrid import components as __common_v1_microgrid_components__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class IncludeOptionsFilterOption(betterproto.Enum):
    """Defines whether to include results in the response message."""

    FILTER_OPTION_UNSPECIFIED = 0
    FILTER_OPTION_EXCLUDE = 1
    FILTER_OPTION_INCLUDE = 2


@dataclass(eq=False, repr=False)
class TimeFilter(betterproto.Message):
    """
    Time-based filter for querying aggregated microgrid components data. !!!
    note     Specifies the start and end time for the query. Both fields are
    optional, but     their absence or presence has specific implications for
    the query results.     Data will be returned as a set of rows, which each
    row containing a timestamp.     This timestamp will be >= start and < end.
    """

    start: datetime = betterproto.message_field(1)
    """
    Optional UTC start time for the query. !!! info     If not provided, the
    query defaults to the earliest available data for the     specified
    microgrid components.
    """

    end: datetime = betterproto.message_field(2)
    """
    Optional UTC end time for the query. !!! info     If not provided, the
    query defaults to the most recent available data for the     specified
    microgrid components.
    """


@dataclass(eq=False, repr=False)
class ResamplingOptions(betterproto.Message):
    """
    Resampling options for aggregated microgrid components data. If data is
    resampled, all samples that fall in a left-closed time interval determined
    by the resolution will be aggregated. At the moment only mean aggregation
    is supported. The timestamp of the aggregated sample corresponds to the
    oldest possible timestamp of the time interval.
    """

    resolution: Optional[int] = betterproto.uint32_field(
        1, optional=True, group="_resolution"
    )
    """
    Optional resampling resolution for the data, represented in seconds. If
    omitted, data will be returned in its original resolution.
    """


@dataclass(eq=False, repr=False)
class IncludeOptions(betterproto.Message):
    """
    Include options for filtering microgrid components data. !!! note
    Specifies which additional fields should be included in the response.
    """

    bounds: Optional["IncludeOptionsFilterOption"] = betterproto.enum_field(
        1, optional=True, group="_bounds"
    )
    """
    Optional bound inclusion. By default, bounds are not included in the
    response.
    """

    states: Optional["IncludeOptionsFilterOption"] = betterproto.enum_field(
        2, optional=True, group="_states"
    )
    """
    Optional operational state inclusion. By default, states are not included
    in the response.
    """


@dataclass(eq=False, repr=False)
class AggregationConfig(betterproto.Message):
    """
    Message defining the aggregation configuration for a custom formula within
    a specific microgrid. The AggregationConfig allows clients to specify how
    metrics should be aggregated across microgrid components. It serves as the
    configuration guideline for any aggregation operation. !!! example    To
    calculate the total voltage across three components in series with IDs 1,
    2, and 3, the     configuration could look like:     {       microgrid_id:
    42,       metric: DC_VOLTAGE_V,       aggregation_formula: "#1 + #2 + #3"
    }
    """

    microgrid_id: int = betterproto.uint64_field(1)
    """ID of the microgrid for which the formula is being specified."""

    metric: "__common_v1_metrics__.Metric" = betterproto.enum_field(2)
    """
    The metric that is to be aggregated using the specified formula. !!!
    caution     Ensure the chosen metric is supported by all relevant microgrid
    components.     Failure to meet these conditions might results in an
    aggregation error.
    """

    aggregation_formula: str = betterproto.string_field(3)
    """
    The formula used for aggregating the component metric for this microgrid.
    !!! info     Two types of aggregation formulas are supported:     1.
    Aggregate functions: These are standard aggregation functions like `sum()`
    and `avg()`.        Example: `sum(#1,#2)`, `avg(#3,#4)`     2. Dedicated
    formulas: These support basic math operators while concatenating microgrid
    component IDs.        Example: `#1 + #2 - #3`, `(#3 * #2) /# 1`
    """


@dataclass(eq=False, repr=False)
class SimpleAggregatedMetricSample(betterproto.Message):
    """
    Defines a single aggregated metric sample, which represents a consolidated
    metric value over a collection of microgrid components within a specific
    timeframe. This message serves to encapsulate aggregate metrics derived
    from multiple component measurements. It is particularly useful in
    scenarios where an overall metric needs to be calculated for a set of
    components. For instance, you could use it to represent the average voltage
    across multiple sources within a microgrid or to calculate the average
    state of charge of several batteries.
    """

    sampled_at: datetime = betterproto.message_field(1)
    """
    The UTC sample timestamp for the aggregated metrics. !!! info     This is
    the original timestamp of the samples that were aggregated.
    """

    sample: "__common_v1_metrics__.SimpleMetricSample" = betterproto.message_field(2)
    """The aggregated value of the metric. float value = 2;"""


@dataclass(eq=False, repr=False)
class ListMicrogridComponentsDataRequest(betterproto.Message):
    """
    Message defining the request format for fetching historical metrics, such
    as electrical measurements, and other information for individual microgrid
    components. !!! note     In addition to the raw metrics, the API can also
    return additional information     like errors or operational states of the
    components during the specified time period.
    """

    microgrid_components: List["__common_v1_microgrid__.MicrogridComponentIDs"] = (
        betterproto.message_field(1)
    )
    """
    Encapsulates the microgrid ID and the component IDs within that microgrid
    for which the historical data should be retrieved. !!! note     Each entry
    in this repeated field associates a microgrid ID with its respective
    component IDs. At least one such association must be provided for a valid
    request.
    """

    metrics: List["__common_v1_metrics__.Metric"] = betterproto.enum_field(2)
    """
    List of metrics to return. Only the specified metrics will be returned. !!!
    note     At least one metric must be specified. Failure to do so will
    result in an empty response.
    """

    filter: "ListMicrogridComponentsDataRequestListFilter" = betterproto.message_field(
        3
    )
    """
    General filter criteria apply to the data retrieval for all specified
    microgrid components. !!! note     The filter can specify a start time and
    end time, and/or resampling options.     It can also specify bounds,
    operational state, or errors to be returned.
    """

    pagination_params: "__common_v1_pagination__.PaginationParams" = (
        betterproto.message_field(4)
    )
    """
    Pagination parameters to control the amount of data returned in a single
    response.
    """


@dataclass(eq=False, repr=False)
class ListMicrogridComponentsDataRequestListFilter(betterproto.Message):
    """General filter criteria for querying microgrid components data."""

    resampling_options: "ResamplingOptions" = betterproto.message_field(1)
    """
    Optional resampling options like resolution for the data, represented in
    seconds. If omitted, data will be returned in its original representation.
    """

    time_filter: "TimeFilter" = betterproto.message_field(2)
    """Optional time-based filter criteria."""

    include_options: "IncludeOptions" = betterproto.message_field(3)
    """
    Include options specifying additional fields to be included in the
    response.
    """


@dataclass(eq=False, repr=False)
class ListMicrogridComponentsDataResponse(betterproto.Message):
    """
    Response containing historical microgrid component metrics in one or
    multiple microgrids Each microgrid's components are provided as timeseries
    data structures that encapsulate metrics, bounds, errors and operational
    state and their associated timestamps for each component within the
    specified time range. !!! example     Example output structure:     ```
    microgrids: [       {         microgrid_id: 1,         components: [
    {             component_id: 13,             metric_samples: [
    /* list of metrics for multiple timestamps */               { sampled_at:
    "2023-10-01T00:00:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds:
    {...} },               { sampled_at: "2023-10-01T00:00:00Z", metric:
    "DC_CURRENT_A", sample: {...}, bounds: {...} }               { sampled_at:
    "2023-10-01T00:05:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds:
    {...} },               { sampled_at: "2023-10-01T00:05:00Z", metric:
    "DC_CURRENT_A", sample: {...}, bounds: {...} }             ],
    states: [               /* list of states for multiple timestamps */
    { sampled_at: "2023-10-01T00:00:13.12Z", states: [...], errors: [...],
    warnings: [...] },               { sampled_at: "2023-10-01T00:02:22.01Z",
    states: [...], errors: [...], warnings: [...] },               {
    sampled_at: "2023-10-01T00:05:02.32Z", states: [...], errors: [...],
    warnings: [...] },             ]           },           {
    component_id: 243,             metric_samples: [ ... ],             states:
    [ ... ]           },         ]       },       {         microgrid_id: 2,
    components: [ ... ]       }     ]     ```
    """

    microgrids: List["ListMicrogridComponentsDataResponseMicrogridData"] = (
        betterproto.message_field(1)
    )
    """List of microgrids metrics timeseries data, organized per component."""

    pagination_info: "__common_v1_pagination__.PaginationInfo" = (
        betterproto.message_field(2)
    )
    """
    Metadata for pagination, including token for the next page to retrieve.
    """


@dataclass(eq=False, repr=False)
class ListMicrogridComponentsDataResponseMicrogridData(betterproto.Message):
    """
    Contains the metric samples for a single microgrid organized by components.
    """

    microgrid_id: int = betterproto.uint64_field(1)
    """Unique microgrid identifier."""

    components: List["__common_v1_microgrid_components__.ComponentData"] = (
        betterproto.message_field(2)
    )
    """A list of components with related metric timeseries data samples."""


@dataclass(eq=False, repr=False)
class ReceiveMicrogridComponentsDataStreamRequest(betterproto.Message):
    """
    Request message for receiving stream of metrics, such as electrical
    measurements, and other information for individual microgrid components.
    !!! note     In addition to the raw metrics, the API can also return
    additional information     like errors or operational states of the
    components during the specified time period.
    """

    microgrid_components: List["__common_v1_microgrid__.MicrogridComponentIDs"] = (
        betterproto.message_field(1)
    )
    """
    Encapsulates the microgrid ID and the component IDs within that microgrid
    for which the historical data should be retrieved. !!! note     Each entry
    in this repeated field associates a microgrid ID with its respective
    component IDs. At least one such association must be provided for a valid
    request.
    """

    metrics: List["__common_v1_metrics__.Metric"] = betterproto.enum_field(2)
    """
    List of metrics to return. Only the specified metrics will be returned. !!!
    note     At least one metric must be specified. Failure to do so will
    result in an empty response.
    """

    filter: "ReceiveMicrogridComponentsDataStreamRequestStreamFilter" = (
        betterproto.message_field(3)
    )
    """
    General filter that applies to the data retrieval for all specified
    microgrids and components. !!! note     The filter can specify a list of
    metrics to be return but also specify bounds, operational     state, or
    errors to be returned.
    """


@dataclass(eq=False, repr=False)
class ReceiveMicrogridComponentsDataStreamRequestStreamFilter(betterproto.Message):
    """
    General filter criteria for querying microgrid components data. !!! note
    The filter criteria defined here are applied universally across all
    specified microgrids and their respective components.
    """

    resampling_options: "ResamplingOptions" = betterproto.message_field(1)
    """
    Optional resampling options like resolution for the data, represented in
    seconds. If omitted, data will be returned in its original representation.
    """

    include_options: "IncludeOptions" = betterproto.message_field(2)
    """
    Include options specifying additional fields to be included in the
    response.
    """


@dataclass(eq=False, repr=False)
class ReceiveMicrogridComponentsDataStreamResponse(betterproto.Message):
    """
    Response containing a single data sample for one microgrid's components.
    !!! note     The microgrid's components are provided as single data samples
    that     encapsulate metrics, bounds, errors, and operational states along
    with their     associated timestamps. Each response message covers a single
    microgrid.     If multiple microgrids are provided in the request, expect
    sequential messages     in the stream. !!! example     Example output
    structure:     ```     {       microgrid_id: 1,       components: [
    {           component_id: 13,           metric_samples: [             /*
    all metrics belong to the same timestamp */             /* sample is type
    MetricSampleVariant */             { sampled_at: "2023-10-01T00:00:00Z",
    metric: "DC_VOLTAGE_V", sample: {...}, bounds: {...} },             {
    sampled_at: "2023-10-01T00:00:00Z", metric: "DC_CURRENT_A", sample: {...},
    bounds: {...} }           ],           state: {             sampled_at:
    "2023-10-01T00:00:13.12Z",             states: ["COMPONENT_STATE_CHARGING",
    "CABLE_CONNECTED"],             warnings: []             errors: [],
    ]         },         {           component_id: 59,
    metric_samples: [             /* all metrics belong to the same timestamp
    */             /* sample is type MetricSampleVariant */             {
    sampled_at: "2023-10-01T00:00:00Z", metric: "DC_VOLTAGE_V", sample: {...},
    bounds: {...} },             { sampled_at: "2023-10-01T00:00:00Z", metric:
    "DC_CURRENT_A", sample: {...}, bounds: {...} }           ],
    state: {             sampled_at: "2023-10-01T00:00:13.12Z",
    states: ["COMPONENT_STATE_ERROR"],             warnings: []
    errors: ["COMPONENT_ERROR_CODE_BATTERY_RELAY_ERROR"],           ]         }
    ]     }     ```
    """

    microgrid_id: int = betterproto.uint64_field(1)
    """Microgrid ID for which the components and samples are reported."""

    components: List["__common_v1_microgrid_components__.ComponentData"] = (
        betterproto.message_field(2)
    )
    """
    List of components within this microgrid, each with its associated data
    samples.
    """


@dataclass(eq=False, repr=False)
class ListAggregatedMicrogridComponentsDataRequest(betterproto.Message):
    """
    Message defining the request format for fetching aggregated historical
    metrics for a list of microgrid components. This request allows to specify
    custom aggregation formulas, along with general filtering and pagination
    options. !!! note         The aggregation follows the passive sign
    convention. Bounds, operational         state, or errors are not applicable
    to aggregated data.
    """

    aggregation_configs: List["AggregationConfig"] = betterproto.message_field(1)
    """
    List of aggregation formulas, composed of a metric and related formula. !!!
    note     Each entry in the list consists of a pairs a metric and
    aggregation formula. Multiple such     aggregations can be specified for a
    list of microgrid components, allowing for different     metrics and
    formula combinations. At least one formula must be provided for a valid
    request.
    """

    filter: "ListAggregatedMicrogridComponentsDataRequestAggregationListFilter" = (
        betterproto.message_field(2)
    )
    """General filter that applies to all formula aggregations provided."""

    pagination_params: "__common_v1_pagination__.PaginationParams" = (
        betterproto.message_field(3)
    )
    """
    Pagination parameters to control the amount of data returned in a single
    response.
    """


@dataclass(eq=False, repr=False)
class ListAggregatedMicrogridComponentsDataRequestAggregationListFilter(
    betterproto.Message
):
    """
    General filter criteria for querying aggregated microgrid components data.
    """

    resampling_options: "ResamplingOptions" = betterproto.message_field(1)
    """
    Optional resampling options like resolution for the data, represented in
    seconds. Data will always be resampled to ensure consistency of the
    aggregation. If omitted, data will be resampled with a default of one
    second
    """

    time_filter: "TimeFilter" = betterproto.message_field(2)
    """Optional time-based filter criteria."""


@dataclass(eq=False, repr=False)
class ListAggregatedMicrogridComponentsDataResponse(betterproto.Message):
    """
    Message defining the response format for a request that fetches aggregated
    historical metrics based on custom aggregation formulas. !!! note     At
    least one formula and metric must have been specified in the corresponding
    request.     The aggregation results for these metrics are returned in the
    samples field. !!! example     Example output structure is the following:
    ```     results: [       {         aggregation_config: {
    microgrid_id: 1,           metric: "DC_VOLTAGE_V",
    aggregation_formula: "avg(3,5,6)"         },         samples: [           {
    sampled_at: "2023-10-01T00:00:00Z", sample: { value: 220.1 } },           {
    sampled_at: "2023-10-01T00:05:00Z", sample: { value: 215.2 } }         ]
    },       {         aggregation_config: {           microgrid_id: 2,
    metric: "DC_CURRENT_A",           aggregation_formula: "sum(1,2,3,4)"
    },         samples: [           { sampled_at: "2023-10-01T00:00:00Z",
    sample: { value: 1310.7 } },           { sampled_at:
    "2023-10-01T00:05:00Z", sample: { value: 1422.2 } }         ]       }     ]
    ```
    """

    results: List["ListAggregatedMicrogridComponentsDataResponseAggregatedResult"] = (
        betterproto.message_field(1)
    )
    """
    List of aggregated results, each corresponding to a metric and custom
    aggregation formula. !!! note     Each entry in this list contains the
    aggregation formula config and the     corresponding aggregated metric
    samples for the requested timeframe.
    """

    pagination_info: "__common_v1_pagination__.PaginationInfo" = (
        betterproto.message_field(2)
    )
    """
    Metadata for pagination, containing the token for the next page of results.
    !!! note     If `pagination_info` is populated, it implies that more data
    is available to fetch.
    """


@dataclass(eq=False, repr=False)
class ListAggregatedMicrogridComponentsDataResponseAggregatedResult(
    betterproto.Message
):
    """Encapsulates the result of aggregating a metric."""

    aggregation_config: "AggregationConfig" = betterproto.message_field(1)
    """Metric and related formula provided for aggregation."""

    samples: List["SimpleAggregatedMetricSample"] = betterproto.message_field(2)
    """A list of aggregated metrics."""


@dataclass(eq=False, repr=False)
class ReceiveAggregatedMicrogridComponentsDataStreamRequest(betterproto.Message):
    """
    Message defining the request format for streaming aggregated historical
    metrics. This request allows to specify custom aggregation formulas, along
    with general filtering. At least one aggregation formula config must be
    provided. The aggregation follows the passive sign convention.
    """

    aggregation_configs: List["AggregationConfig"] = betterproto.message_field(1)
    """List of pairs of metric and corresponding aggregation formula."""

    filter: (
        "ReceiveAggregatedMicrogridComponentsDataStreamRequestAggregationStreamFilter"
    ) = betterproto.message_field(2)
    """General streaming filter that applies to all formula aggregations."""


@dataclass(eq=False, repr=False)
class ReceiveAggregatedMicrogridComponentsDataStreamRequestAggregationStreamFilter(
    betterproto.Message
):
    """General filter criteria for querying microgrid components data."""

    resampling_options: "ResamplingOptions" = betterproto.message_field(1)
    """
    Optional resampling options like resolution for the data, represented in
    seconds. If omitted, data will be returned in its original representation.
    """


@dataclass(eq=False, repr=False)
class ReceiveAggregatedMicrogridComponentsDataStreamResponse(betterproto.Message):
    """
    Message defining the response format for a stream that fetches aggregated
    real-time metrics for the provided custom aggregation formulas. !!! note
    The formula and metric must have been specified in the corresponding
    request.     A single aggregated sample for the metric is returned in the
    sample field. Each message     covers a single formula. For multiple
    formulars provided in the request, expect sequential     messages in the
    stream. !!! example     Given a stream output, a single sample might be:
    ```     {       aggregation_config: {         microgrid_id: 1,
    metric: "DC_VOLTAGE_V",         aggregation_formula: "avg(1,2,3)"       },
    sample {         sampled_at: '2023-10-01T00:00:00Z',         sample: {
    value: 42.5 }       }     }     ```
    """

    aggregation_config: "AggregationConfig" = betterproto.message_field(1)
    """The metric and formula that has been used to aggregate the sample."""

    sample: "SimpleAggregatedMetricSample" = betterproto.message_field(2)
    """
    Aggregated sample value and corresponding UTC timestamp when it was
    sampled.
    """


class ReportingStub(betterproto.ServiceStub):
    async def list_microgrid_components_data(
        self,
        list_microgrid_components_data_request: "ListMicrogridComponentsDataRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListMicrogridComponentsDataResponse":
        return await self._unary_unary(
            "/frequenz.api.reporting.v1.Reporting/ListMicrogridComponentsData",
            list_microgrid_components_data_request,
            ListMicrogridComponentsDataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def receive_microgrid_components_data_stream(
        self,
        receive_microgrid_components_data_stream_request: "ReceiveMicrogridComponentsDataStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ReceiveMicrogridComponentsDataStreamResponse"]:
        async for response in self._unary_stream(
            "/frequenz.api.reporting.v1.Reporting/ReceiveMicrogridComponentsDataStream",
            receive_microgrid_components_data_stream_request,
            ReceiveMicrogridComponentsDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def list_aggregated_microgrid_components_data(
        self,
        list_aggregated_microgrid_components_data_request: "ListAggregatedMicrogridComponentsDataRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListAggregatedMicrogridComponentsDataResponse":
        return await self._unary_unary(
            "/frequenz.api.reporting.v1.Reporting/ListAggregatedMicrogridComponentsData",
            list_aggregated_microgrid_components_data_request,
            ListAggregatedMicrogridComponentsDataResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def receive_aggregated_microgrid_components_data_stream(
        self,
        receive_aggregated_microgrid_components_data_stream_request: "ReceiveAggregatedMicrogridComponentsDataStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ReceiveAggregatedMicrogridComponentsDataStreamResponse"]:
        async for response in self._unary_stream(
            "/frequenz.api.reporting.v1.Reporting/ReceiveAggregatedMicrogridComponentsDataStream",
            receive_aggregated_microgrid_components_data_stream_request,
            ReceiveAggregatedMicrogridComponentsDataStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ReportingBase(ServiceBase):

    async def list_microgrid_components_data(
        self,
        list_microgrid_components_data_request: "ListMicrogridComponentsDataRequest",
    ) -> "ListMicrogridComponentsDataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def receive_microgrid_components_data_stream(
        self,
        receive_microgrid_components_data_stream_request: "ReceiveMicrogridComponentsDataStreamRequest",
    ) -> AsyncIterator["ReceiveMicrogridComponentsDataStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ReceiveMicrogridComponentsDataStreamResponse()

    async def list_aggregated_microgrid_components_data(
        self,
        list_aggregated_microgrid_components_data_request: "ListAggregatedMicrogridComponentsDataRequest",
    ) -> "ListAggregatedMicrogridComponentsDataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def receive_aggregated_microgrid_components_data_stream(
        self,
        receive_aggregated_microgrid_components_data_stream_request: "ReceiveAggregatedMicrogridComponentsDataStreamRequest",
    ) -> AsyncIterator["ReceiveAggregatedMicrogridComponentsDataStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ReceiveAggregatedMicrogridComponentsDataStreamResponse()

    async def __rpc_list_microgrid_components_data(
        self,
        stream: "grpclib.server.Stream[ListMicrogridComponentsDataRequest, ListMicrogridComponentsDataResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_microgrid_components_data(request)
        await stream.send_message(response)

    async def __rpc_receive_microgrid_components_data_stream(
        self,
        stream: "grpclib.server.Stream[ReceiveMicrogridComponentsDataStreamRequest, ReceiveMicrogridComponentsDataStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.receive_microgrid_components_data_stream,
            stream,
            request,
        )

    async def __rpc_list_aggregated_microgrid_components_data(
        self,
        stream: "grpclib.server.Stream[ListAggregatedMicrogridComponentsDataRequest, ListAggregatedMicrogridComponentsDataResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_aggregated_microgrid_components_data(request)
        await stream.send_message(response)

    async def __rpc_receive_aggregated_microgrid_components_data_stream(
        self,
        stream: "grpclib.server.Stream[ReceiveAggregatedMicrogridComponentsDataStreamRequest, ReceiveAggregatedMicrogridComponentsDataStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.receive_aggregated_microgrid_components_data_stream,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/frequenz.api.reporting.v1.Reporting/ListMicrogridComponentsData": grpclib.const.Handler(
                self.__rpc_list_microgrid_components_data,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListMicrogridComponentsDataRequest,
                ListMicrogridComponentsDataResponse,
            ),
            "/frequenz.api.reporting.v1.Reporting/ReceiveMicrogridComponentsDataStream": grpclib.const.Handler(
                self.__rpc_receive_microgrid_components_data_stream,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReceiveMicrogridComponentsDataStreamRequest,
                ReceiveMicrogridComponentsDataStreamResponse,
            ),
            "/frequenz.api.reporting.v1.Reporting/ListAggregatedMicrogridComponentsData": grpclib.const.Handler(
                self.__rpc_list_aggregated_microgrid_components_data,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListAggregatedMicrogridComponentsDataRequest,
                ListAggregatedMicrogridComponentsDataResponse,
            ),
            "/frequenz.api.reporting.v1.Reporting/ReceiveAggregatedMicrogridComponentsDataStream": grpclib.const.Handler(
                self.__rpc_receive_aggregated_microgrid_components_data_stream,
                grpclib.const.Cardinality.UNARY_STREAM,
                ReceiveAggregatedMicrogridComponentsDataStreamRequest,
                ReceiveAggregatedMicrogridComponentsDataStreamResponse,
            ),
        }
